# -*- Mode: shell-script; indent-tabs-mode: nil -*-

# https://stackoverflow.com/questions/1128496/to-get-a-prompt-which-indicates-git-branch-in-zsh
setopt prompt_subst
autoload -Uz vcs_info
zstyle ':vcs_info:*' stagedstr 'M'
zstyle ':vcs_info:*' unstagedstr 'M'
zstyle ':vcs_info:*' check-for-changes true
zstyle ':vcs_info:*' actionformats '%F{5}[%F{2}%b%F{3}|%F{1}%a%F{5}]%f '
zstyle ':vcs_info:*' formats       '%F{5}[%F{2}%b%F{5}] %F{2}%c%F{3}%u%f'
zstyle ':vcs_info:git*+set-message:*' hooks git-untracked
zstyle ':vcs_info:*' enable git
+vi-git-untracked() {
    # if [[ $(git rev-parse --is-inside-work-tree 2> /dev/null) == 'true' ]] &&
    #        [[ $(git ls-files --other --directory --exclude-standard | sed q | wc -l | tr -d ' ') == 1 ]]
    # then
    #     hook_com[unstaged]+='%F{1}??%f'
    # fi
    :
}

# time
# RPROMPT='%D{%k:%M:%S}'

# https://stackoverflow.com/questions/60323738/bash-and-zsh-prompt-that-ring-a-bell-and-do-display-error-code-of-last-command
BLK=$(tput setaf 0; tput bold)
RED=$(tput setaf 1; tput bold)
grn=$(tput setaf 2)
GRN=$(tput setaf 2; tput bold)
yel=$(tput setaf 3)
reset_color=$(tput sgr0)

function set_title() {
    printf '\033]0;%s%s' "$1" "$(tput bel)"
}

function make_prompt() {
    local last_cmd_status="$1"
    local st c bell
    st=$?
    bell=$(tput bel)

    # Green for success, red and a bell for failure
    if [[ $st -gt 0 ]]
    then
        c=31
    else
        c=32 bell=
    fi

    win_title=$(set_title "$PWD")
    # git_status=$(__git_ps1)

    win_title=$(set_title "$PWD")
    # git_status=$(__git_ps1)

    ## see http://www.nparikh.org/unix/prompt.php

    if [[  $TERM == "screen" ]]
    then
        # these color create alignment problem in screen term.
        fg=()
        reset_color=
        x_bold=
        x_unbold=
    else
        x_bold="%B"
        x_unbold="%b"
    fi

    if whence -p errno >& /dev/null
    then
        cmd_status="$(errno $last_cmd_status| cut -d' ' -f1,3-) "
    fi


    ##{{ PROMPT PS1
    if [ "$SSH_CONNECTION" ]
    then

        if ! ps1_ssh_from_host=${$(timeout3 -t 1 resolveip -s ${${(z)SSH_CONNECTION}[1]} 2>/dev/null)//.*/} 2>/dev/null
        then
            ps1_ssh_from_host=${${(z)SSH_CONNECTION}[1]}
        fi
        if ! ps1_ssh_to_host=${$(timeout3 -t 1 resolveip -s ${${(z)SSH_CONNECTION}[3]} 2>/dev/null)//.*/} 2>/dev/null
        then
            ps1_ssh_to_host=${${(z)SSH_CONNECTION}[3]}
        fi
        ps1ssh_connection=%{$fg[green]%}${x_bold}${ps1_ssh_from_host}${x_unbold}%{$reset_color%}'>'
    fi


    local ps1_user_default=s
    local ps1_host_default=taj

    # come first
    if [[  $TERM == "screen" ]]
    then
        local ps1shlv="%L"
    else
        local ps1shlv="%{$fg[magenta]%}%L%{${reset_color}%}"
    fi
    # comes second
    local slash_b4_ps1screen="%(2L./.)"
    # some changes done in it, for getting it correct, any of these below two will work.
    if [[  $TERM == "screen" ]]
    then
        [ $WINDOW ] && local ps1screen="${WINDOW+${slash_b4_ps1screen}$WINDOW}"
    else
        [ $WINDOW ] && local ps1screen="${WINDOW+${slash_b4_ps1screen}%{${fg[yellow]}$WINDOW%}\%{$reset_color%}"
    fi
    unset slash_b4_ps1screen
    #local ps1_screen=${WINDOW:+/%{$fg[yellow]%}${WINDOW}%{${reset_color}%}}

    # %(1j./.)  # 1 job then place / else noting
    # %(1j.. )  # 1 job then nothing else a space

    # comes third
    if [ $WINDOW ]
    then
        local slash_b4_ps1job="/"
    else
        local slash_b4_ps1job="%(2L./.)"
    fi
    # %(1j.%{$fg[green]%}%j%{${reset_color}%}%(2L.. ).)
    # >= 1 job then put %{$fg[green]%}%j%{${reset_color}%}%(2L.. ) else nothing
    # %(2L.. ) # shell level >= 2 then nothing else a space.
    # local ps1job="%(1j./%{$fg[green]%}%j%{${reset_color}%}%(2L.. ).)"
    if [[  $TERM == "screen" ]]
    then
        local ps1job="${slash_b4_ps1job}%j"
    else
        local ps1job="${slash_b4_ps1job}%{$fg[green]%}%j%{${reset_color}%}"
    fi
    unset slash_b4_ps1job

    if [[  $TERM == "screen" ]]
    then
        local ps1shlv_n_screen_n_job="%(2L.${ps1shlv}.)${ps1screen}%(1j.${ps1job}.)"
    else
        local ps1shlv_n_screen_n_job="%(2L.${ps1shlv}.)${ps1screen}%(1j.${ps1job}.)"
    fi

    if [[ $USER != $ps1_user_default && $USER != "spratap" ]]
    then
        local ps1_user_at_host="%U%n%u"
    fi

    # if [[ $HOST != $ps1_host_default && $HOST != "pcz-c-sharad" ]] then
    if [ $ps1_ssh_to_host ]
    then
        if [ $ps1_user_at_host ]
        then
            local ps1_user_at_host="${ps1_user_at_host}@"
        fi
        if [[  $TERM == "XYZ" ]]
        then
            # local ps1_user_at_host="${ps1_user_at_host}${x_bold}%m${x_unbold}"
            local ps1_user_at_host="${ps1_user_at_host}${x_bold}${ps1_ssh_to_host}${x_unbold}"
        else
            # local ps1_user_at_host="${ps1_user_at_host}%{$fg[yellow]%}${x_bold}%m${x_unbold}%{$reset_color%}"
            local ps1_user_at_host="${ps1_user_at_host}%{$fg[yellow]%}${x_bold}${ps1_ssh_to_host}${x_unbold}%{$reset_color%}"
        fi
    fi

    if [ "$ps1_user_at_host" -o "$WINDOW" ]
    then
        local spacing_b4_ps1status="%(2L..%(1j.. ))"
    fi

    # # will have both side space
    # if [[  $TERM == "XYZ" ]] then
    #     local ps1status="%(?..%S%?%s )"
    # else
    #     if [[  $TERM == "screen" ]] then
    #         local ps1status="%(?..%? )"
    #     else
    #         local ps1status="%(?..%S%{$fg[red]%}%?%{$reset_color%}%s )"
    #     fi
    # fi

    # will have both side space
    if [[  $TERM == "XYZ" ]]
    then
        local ps1status="%(?..%S%?%s )"
    else
        if [[  $TERM == "screen" ]]
        then
            local ps1status="%(?..%? )"
        else
            local ps1status="%(?..%S%{$fg[red]%}${cmd_status}[%?]%{$reset_color%}%s )"
        fi
    fi

    # time at next hour
    if [[  $TERM == "screen" ]]
    then
        local ps1_time_at_hour="%(0t.%t .)"
    else
        local ps1_time_at_hour="%(0t.%{$fg[red]%}%t%{$reset_color%} .)"
    fi

    local ps1_dir='%2~'
    # local ps1_dir='%(1~.%2~.)'
    if [[  $TERM == "screen" ]]
    then
        local ps1_prompt_char='%(!.#.%%)'
    else
        local ps1_prompt_char="%(!.${x_bold}#${x_unbold}.%%)"
    fi

    if [ $WINDOW ]
    then
        local spacing=" "
    else
        local spacing="%(2L.%(1j. .) .%(1j. .))"
    fi

    ps1_extra_stage1="${vcs_info_msg_0_}"
    ps1_extra="${ps1_extra_stage1:+<$ps1_extra_stage1>}"





    if [ ! $SUDO_USER ]
    then
        PS1="${ps1ssh_connection}${ps1shlv_n_screen_n_job}${spacing}${ps1_user_at_host:+${ps1_user_at_host} }${ps1_time_at_hour}${spacing_b4_ps1status}${ps1status}${ps1_dir}${ps1_extra}${ps1_prompt_char} "
        # PS1="${ps1ssh_connection}${spacing}${ps1_user_at_host:+${ps1_user_at_host} }${ps1_time_at_hour}${spacing_b4_ps1status}${ps1status}${ps1_dir}${ps1_prompt_char} "
    else
        PS1='$ '
    fi

    unset ps1shlv_n_screen_n_job spacing ps1_user_at_host \
          ps1_user_at_host ps1_time_at_hour spacing_b4_ps1status \
          ps1status ps1_dir ps1_prompt_char ps1_ssh_to_host \
          ps1_ssh_from_host ps1ssh_connection
}

PROMPT_COMMAND=make_prompt

autoload -U promptinit; promptinit

##}} PROMPT PS1

#         periodic_functions=( show_agenda )
#         function show_agenda {
#             if (( TTYIDLE > 2 )) ; then
#                 echo Hi
#             fi
#         }
#         PERIOD=1


##{{ PROMPT RPROMPT
# https://coderwall.com/p/kmchbw/zsh-display-commands-runtime-in-prompt


function preexec_duration_print() {
  timer=${timer:-$SECONDS}
}

function precmd_duration_print() {
    if [ $timer ]
    then
        __duration=$(($SECONDS - $timer))
        if (( $__duration > 0 ))
        then
            if [[  $TERM == "screen" ]]
            then
                __timer_show="${__duration}s"
            else
                __timer_show="%{$fg[cyan]%}${__duration}%{$reset_color%}s"
            fi
            export RPROMPT="$__timer_show"
        else
            __timer_show=
            export RPROMPT=
        fi
        unset timer
  fi
}

function preexec_prompt_command() {
    local last_cmd_status=$?
    make_prompt ${last_cmd_status}
}

preexec_functions+=(preexec_duration_print)
precmd_functions+=(preexec_prompt_command)
precmd_functions+=(precmd_duration_print)
precmd_functions+=(vcs_info)
##}} PROMPT PS1


##{{ PROMPT PS1
##}} PROMPT PS1
