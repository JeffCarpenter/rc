# -*- mode: shell-script; -*-

if [ "x" = "x$HOST" ]
then
    HOST=$HOSNAME
    export HOST
fi

## GUIX
#
# Source the system-wide file.
# if [ -r /etc/profile ]
# then
#     # preventing gnome-sesion to start from gdm
#     . /etc/profile
# fi
GUIX_PROFILE="$HOME/.guix-profile"
if [ -r $GUIX_PROFILE/etc/profile ]
then
  . $GUIX_PROFILE/etc/profile
fi
export GUIX_PROFILE
# export GUIX_LOCPATH=$HOME/.guix-profile/lib/locale

# https://guix.gnu.org/cookbook/en/html_node/Basic-setup-with-manifests.html#Basic-setup-with-manifests
LOCAL_GUIX_EXTRA_PROFILES=("dev" "dynamic-hash" "heavy" "lengthy")
export LOCAL_GUIX_EXTRA_PROFILES
## GUIX

if [ "x" != "x$SSL_CERT_FILE" ]
then
    LDAPTLS_CACERT=$SSL_CERT_FILE
    export LDAPTLS_CACERT
fi

# default values
if [ "x" != "x$OFFLINEIMAPACCOUNT" ]
then
    OFFLINEIMAPACCOUNT=Gmail
    export OFFLINEIMAPACCOUNT
fi
if [ "x" != "x$WORKPLACE" ]
then
    WORKPLACE=merunetworks.com
    export WORKPLACE
fi

if [ "x$EMACS_SERVER_NAME" = "x" ]
then
    EMACS_SERVER_NAME=general
    export EMACS_SERVER_NAME
fi

if [ "x$EMACS_DIST_DIR" = "x" ]
then
    EMACS_DIST_DIR=.xemacs
    export EMACS_DIST_DIR
fi

if [ "z" != "z$EMACS_SERVER_NAME" ]
then
    EDITOR="emacsclient -t -c -f ~/.emacs.d/server/$EMACS_SERVER_NAME "
    export EDITOR
    VISUAL="$EDITOR"
    export VISUAL
fi

if [ "x${REMOTEEDITORHOST}" != "x" ] ; then
    EDITOR=$HOME/bin/rgeneral-editor
else
    EDITOR=$HOME/bin/general-editor
fi
export EDITOR

BROWSER=w3m
export BROWSER



# default values








if [ "x${HOST}" = "x" ]
then
    HOST=$HOSTNAME
    export HOST
fi

if [ "x${HOST}" != "x" ]
then
    __comp=sh

    if [ -d ~/.rsetup/${__comp}/env.d/${HOST} ]
    then
        rm -rf ~/.rsetup/${__comp}/env.d/${HOST}
    fi
    if [ ! -e ~/.rsetup/${__comp}/env.d/${HOST} ]
    then
        mkdir -p ~/.setup/osetup/setup/rsetup.d/sh.d/env.d
        cp ~/.rsetup/${__comp}/env.tmpl ~/.rsetup/${__comp}/env.d/${HOST}
    fi

    if [ -r ~/.rsetup/${__comp}/env.d/${HOST} ]
    then
        . ~/.rsetup/${__comp}/env.d/${HOST}
    fi
    unset __comp
else
    echo env var HOST is not set $HOST
fi

if [ -r ~/.LESS_TERMCAP ]
then
    source ~/.LESS_TERMCAP
fi

export EDITOR
export VISUAL
export BROWSER
export EMACS_DIST_DIR

GIT_DISCOVERY_ACROSS_FILESYSTEM=1
export GIT_DISCOVERY_ACROSS_FILESYSTEM


if [ -r /var/lib/dbus/machine-id ]
then
    MACHINE_ID=/var/lib/dbus/machine-id
elif [ -r /etc/machine-id ]
then
    MACHINE_ID=/etc/machine-id
fi

if [ -r "$MACHINE_ID" ]
then
    # GUIX
    MY_DBUS_SESSION="$(cat ${MACHINE_ID})"
    export MY_DBUS_SESSION
fi
unset MACHINE_ID

if [ "x" != "x$WORKPLACE" ]
then
    if [  -d ~/.opt/p/$WORKPLACE ]
    then
        . ~/.opt/p/$WORKPLACE/env
        # ~/.opt/p/$WORKPLACE/run
    else
        echo ~/.opt/p/$WORKPLACE directory  do not exits, so setup ~/.opt/ directory. >&2
    fi
else
    if [ ! $SUDO_USER ] && [ "$TERM" != "dumb" ]
    then
        echo WORKPLACE is not set. >&2
    fi
fi

function ssh_agent_present_p()
{
    if whence -p ssh-agent >/dev/null 2>&1
    then
        true
    else
        false
    fi
}

function ssh_agent_alive_p()
{
    if whence -p ssh-agent >/dev/null 2>&1
    then
        if [ "x${SSH_AUTH_SOCK}" != "x" ]
        then
            if [ -e ${SSH_AUTH_SOCK} ]
            then
                if [ "x${SSH_AGENT_PID}" = "x" ]
                then
                    true
                else
                    if ps ${SSH_AGENT_PID} 2>&1 > /dev/null
                    then
                        true
                    else
                        false
                    fi
                fi
            else
                false
            fi
        else
            false
        fi
    else
        false
    fi
}
function ssh_agent_call_p()
{
    ! ssh_agent_present_p || ! ssh_agent_alive_p
}

function dbus_present_p()
{
    whence -p dbus-launch >& /dev/null && [ "x$MY_DBUS_SESSION" != "x" ]
}

function dbus_alive_p()
{
    if dbus_present_p
    then
        if [ "x" != "x$DBUS_SESSION_BUS_ADDRESS" ]
        then
            true
        else
            false
        fi
    else
        false
    fi
}

function dbus_call_p()
{
    ! dbus_present_p || ! dbus_alive_p
}

function emacs_daemon_start()
{
    if whence -p emacs >& /dev/null || ! pgrep -u "$(id -u)" emacs >& /dev/null
    then
	      echo emacs >& /dev/null

        if [ "x$EMACS_SERVER_NAME" = "x" ]
        then
            EMACS_SERVER_NAME=general
            export EMACS_SERVER_NAME
        fi

        if [ "x$EMACS_DIST_DIR" = "x" ]
        then
            EMACS_DIST_DIR=.xemacs
            export EMACS_DIST_DIR
        fi

        __cwd=$(pwd)

        if [ -d ~/../paradise ]
        then
            cd ~/../paradise
        fi

        if true
           then
               for server in $EMACS_SERVER_NAME
               do
                   if [ ! -e ~/.emacs.d/server/${server} ] ||
                          # bundler command is not here for timeout it only for zsh
                          # do not delete: timeout [ TIMEOUT ] don't recognize command `command', it is only for zsh
                          # ! timeout 7 emacsclient -f ~/.emacs.d/server/${server}  -e '(message "works")' > /dev/null 2>&1
                       ! ps $(head -1 ~/.emacs.d/server/${server} | cut -d' ' -f2)
                   then
                       # blow one is not allow gnus to read its ~/.gnus file automatically.
	                     # rm -f   \#.ido.last\#
                       pkill -u "$(id -u)" emacs
                       sleep 2s
                       pkill -u "$(id -u)" -9 emacs
                       sleep 1s

                       EMACS_STARTUP_LOG_DIR=~/.emacs.d/.cache/startup/$server/
                       mkdir -p $EMACS_STARTUP_LOG_DIR

                       # export GDK_RGBA=0
                       # EMACS_SERVER_NAME=$server command emacs --daemon=$server |& tee $EMACS_STARTUP_LOG_DIR/startup.log
                       # GDK_RGBA=0 EMACS_SERVER_NAME=$server command emacs --daemon=$server |& tee $EMACS_STARTUP_LOG_DIR/startup.log
                       if [ "x$MY_DBUS_SESSION" != "x" ] && whence -p dbus-launch >& /dev/null
                       then
                           SHELL=bash GDK_RGBA=0 EMACS_SERVER_NAME=$server  DISPLAY=${DISPLAY-:0.0} timeout 240s dbus-launch --autolaunch=$MY_DBUS_SESSION emacs --daemon=$server 2>&1 | tee $EMACS_STARTUP_LOG_DIR/startup.log
                       else
                           SHELL=bash GDK_RGBA=0 EMACS_SERVER_NAME=$server  DISPLAY=${DISPLAY-:0.0} timeout 240s emacs --daemon=$server |& tee $EMACS_STARTUP_LOG_DIR/startup.log
                       fi

                       echo "Emacs Daemon started\n\n\n\nstatus $?\n\n" >> $EMACS_STARTUP_LOG_DIR/startup.log
                       unset EMACS_STARTUP_LOG_DIR

                       # disown %emacs
                   fi
               done
	             echo emacs1 >& /dev/null
        fi

        cd $__cwd
        unset __cwd
    fi # if whence -p emacs >& /dev/null || ! pgrep -u "$(id -u)" emacs >& /dev/null
}

function ssh_agent_use_run_keychain()
{
    if [ "x${SSH_AUTH_SOCK}" = "x" ]
    then
        if [ "x${SSH_AGENT_PID}" = "x" ]
        then
            if [ -e $RUN_KEYRING ]
            then
                SSH_AUTH_SOCK=$RUN_KEYRING
            fi
        fi
    fi
}

function eval_guix_profiles()
{
    GUIX_PROFILE="$HOME/.guix-profile"
    if [ -r $GUIX_PROFILE/etc/profile ]
    then
        # https://guix.gnu.org/blog/2019/guix-profiles-in-practice/
        # https://guix.gnu.org/cookbook/en/
        # https://guix.gnu.org/cookbook/en/html_node/
        # https://guix.gnu.org/cookbook/en/html_node/Advanced-package-management.html#Advanced-package-management
        # https://guix.gnu.org/cookbook/en/html_node/Basic-setup-with-manifests.html#Basic-setup-with-manifests
        LOCAL_GUIX_EXTRA_PROFILE_CONTAINER_DIR="$HOME/.setup/guix-config/per-user/$USER"
        for profile in "${LOCAL_GUIX_EXTRA_PROFILES[@]}"
        do
            profile_path="$LOCAL_GUIX_EXTRA_PROFILE_CONTAINER_DIR"/"$profile"/profiles.d/"$profile"
            if [ -f "$profile_path"/etc/profile ]
            then
                eval $(guix package  -p "$profile_path" --search-paths=suffix)
            # else
            #    echo file "${profile_path}"/etc/profile not exist, for "${profile_path}" >&2
            fi
            unset profile_path
            unset profile
        done
    fi
}

## 
ssh_agent_use_run_keychain

if [ "x${HOST}" = "x" ]
then
    HOST=$HOSTNAME
fi

if [ "x${HOST}" != "x" ]
then
  __comp=sh

  if [ -d ~/.rsetup/${__comp}/env.d/${HOST} ]
  then
      rm -rf ~/.rsetup/${__comp}/env.d/${HOST}
  fi
  if [ ! -e ~/.rsetup/${__comp}/env.d/${HOST} ]
  then
      mkdir -p ~/.setup/osetup/setup/rsetup.d/sh.d/env.d
      cp ~/.rsetup/${__comp}/env.tmpl ~/.rsetup/${__comp}/env.d/${HOST}
  fi

  if [ -r ~/.rsetup/${__comp}/env.d/${HOST} ]
  then
      . ~/.rsetup/${__comp}/env.d/${HOST}
  fi
  unset __comp
else
    echo env var HOST is not set $HOST
fi

unset MACHINE_ID


## GUIX
eval_guix_profiles
## GUIX
## PATH
possible_path=( ~/bin
                /usr/local/bin
                /usr/local/sbin
                ~/.local/bin
                ~/.cask/bin
                /bin
                /sbin
                /usr/bin
                /usr/sbin
                ~/.emacs.d/term-cmd
                /home/linuxbrew/.linuxbrew/bin )

for _path in "${possible_path[@]}"
do
    if [ -d $_path ]
    then
        PATH=$PATH:$_path
    fi
done
unset _path
unset possible_path
PATH=$PATH:
export PATH
# PATH
