#!/bin/zsh


if ! (( ${+RSETUP_LOGIN_RUN} )) ; then
    RSETUP_LOGIN_RUN=done
else
    exit 0;
fi

if [ ! "$SSH_CONNECTION" -a $(id -u) -ne 0 ] ; then # don't open on ssh connection, and when user is root.

    if whence -p amixer >& /dev/null ; then
# Music
## Playback
        amixer -- sset  Master   100% unmute
        amixer -- sset  PCM      100% unmute
        amixer -- sset  Speaker       unmute
        amixer -- sset  Beep     100% unmute

## Capture
        amixer -- sset 'Front Mic Boost' 0%
        amixer -- sset 'Mic Boost'       0%

## Do not know
        amixer -- sset 'Caller ID'   mute
        amixer -- sset 'Off-hook'    mute
    fi


    if [  -e $PRIVATE_DIR ] && [ "x" != "x$DISPLAY" ] ; then
        [ -x $HOME/bin/ecryptfs-mount-private ] &&
        timeout 7 $HOME/bin/ecryptfs-mount-private
    fi


    if whence -p remind >& /dev/null && ! pgrep remind  >& /dev/null ; then
    # remind -z1 \
    #     -k"~/bin/popremind %s &" \
    #     ${DOTREMINDERS-~/.Organize/remind/Reminders/init.rem} &!

        if [ -r ${DOTREMINDERS-~/.Organize/remind/Reminders/init.rem} ] ; then
            remind -z1 \
                -k~/bin/popremind\ %s\ \& \
                ${DOTREMINDERS-~/.Organize/remind/Reminders/init.rem} &!
        fi

    # for testing remind that do not go into daemon mode, try below command
    # remind -aqh -k"~/bin/popremind %s &" ${DOTREMINDERS-~/.Organize/remind/Reminders/init.rem}

    fi

    if whence -p emacs >& /dev/null || ! pgrep emacs >& /dev/null ; then
	echo emacs
        foreach server (general) {
            if [ ! -e ~/.emacs.d/server/${server} ] ||
       	        ! { # bundler command is not here for timeout it only for zsh
                # do not delete: timeout [ TIMEOUT ] don't recognize command `command', it is only for zsh
                timeout 7 emacsclient -f ~/.emacs.d/server/${server}  -e '(message "works")';
                # timeout 10 emacsclient -f ~/.emacs.d/server/${server}  -e '(message "works")'

                # timeout 16 emacsclient -f ~/.emacs.d/server/${server}  -e '(message "works")';
                } ; then
            # blow one is not allow gnus to read its ~/.gnus file automatically.
	        # rm -f   \#.ido.last\#
                pkill emacs
                # export GDK_RGBA=0
                # EMACS_SERVER_NAME=$server command emacs --daemon=$server |& tee ~/.emacs.d/startup.log
                # GDK_RGBA=0 EMACS_SERVER_NAME=$server command emacs --daemon=$server |& tee ~/.emacs.d/startup.log
                GDK_RGBA=0 EMACS_SERVER_NAME=$server timeout 240s emacs --daemon=$server |& tee ~/.emacs.d/startup.log
                print "Emacs Daemon started\n\n\n\nstatus $?\n\n" >> ~/.emacs.d/startup.log

                # disown %emacs
            # else   #  it cause problem in autologin in GDM,  LightDM
            #     command emacsclient -n -f ~/.emacs.d/server/${server}  -e '(progn (update-ssh-agent) (plan))';
            fi
        }
	echo emacs1
    fi

    # foreach server (general) {
    #     if [ ! -e ~/.emacs.d/server/${server} ] ||
    #         # do notr delete: timeout [ TIMEOUT ] don't recognize command `command', it is only for zsh
    #    	    ! timeout 7 emacsclient -f ~/.emacs.d/server/${server}  -e '(message "works")'; then
    #         # blow one is not allow gnus to read its ~/.gnus file automatically.
    #         pkill emacs ; EMACS_SERVER_NAME=$server command emacs --daemon=$server
    #     fi
    # }

fi






whence leave  >& /dev/null &&
leave +0800

atq
if [ $(atq | cut -f1 | wc -l) -gt 0 ] ; then
    atrm  $(atq | cut -f1)
fi






if [ "x${HOST}" != "x" ] ; then
    __comp=login


    if [ -d ~/.rsetup/${__comp}/run.d/${HOST} ] ; then
        rm -rf ~/.rsetup/${__comp}/run.d/${HOST}
    fi
    if [ ! -x ~/.rsetup/${__comp}/run.d/${HOST} ] ; then
        mkdir ~/.rsetup/${__comp}/run.d/
        cp ~/.rsetup/${__comp}/run.tmpl ~/.rsetup/${__comp}/run.d/${HOST}
    fi

    if [ -r ~/.rsetup/${__comp}/run.d/${HOST} ] ; then
        ~/.rsetup/${__comp}/run.d/${HOST}
    fi

    unset __comp
else
    print env var HOST is not set $HOST
fi
